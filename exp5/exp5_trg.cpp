/**
 * ------------------------ Auto-generated Code ------------------------ 
 *           This code was generated by the Insieme Compiler 
 * --------------------------------------------------------------------- 
 */
#include <ir_interface.h>
#include <irt_all_impls.h>
#include <standalone.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
#define INS_INIT(...) __VA_ARGS__
#else
#define INS_INIT(...) (__VA_ARGS__)
#endif
#ifdef __cplusplus
#include <new>
#define INS_INPLACE_INIT(Loc,Type) new(Loc) Type
#else
#define INS_INPLACE_INIT(Loc,Type) *(Loc) = (Type)
#endif
#ifdef __cplusplus
				/** Workaround for libstdc++/libc bug.
				 *  There's an inconsistency between libstdc++ and libc regarding whether
				 *  ::gets is declared or not, which is only evident when using certain
				 *  compilers and language settings
				 *  (tested positively with clang 3.9 --std=c++14 and libc 2.17).
				 */
				#include <initializer_list>  // force libstdc++ to include its config
				#undef _GLIBCXX_HAVE_GETS    // correct broken config
#endif

/* ------- Program Code --------- */

extern irt_wi_implementation g_insieme_impl_table[];
struct __insieme_type_19;
typedef struct __insieme_type_19 __insieme_type_19;

struct __insieme_type_11;
typedef struct __insieme_type_11 __insieme_type_11;

struct __insieme_type_19 {
    irt_type_id c0;
    const int32_t* c1;
    __insieme_type_11* c2;;
};

struct __insieme_type_24;
typedef struct __insieme_type_24 __insieme_type_24;

struct __insieme_type_24 {
    irt_type_id c0;
    const int32_t* c1;
    __insieme_type_11* c2;
    int32_t* c3;
    int32_t* c4;
    int32_t* c5;
    int32_t* c6;;
};

struct __insieme_type_28;
typedef struct __insieme_type_28 __insieme_type_28;

struct __insieme_type_28 {
    irt_type_id c0;
    int32_t c1;
    char** c2;
    int32_t* c3;;
};

// --- components for type table entries ---
irt_type_id g_type_2_components[] = {1};
irt_type_id g_type_4_components[] = {0,2,3};
irt_type_id g_type_6_components[] = {5};
irt_type_id g_type_7_components[] = {0,2,3,6,6,6,6};
irt_type_id g_type_9_components[] = {8};
irt_type_id g_type_10_components[] = {0,5,9,6};

// --- components_offset for type table entries ---
size_t g_type_4_components_offset[] = {offsetof(__insieme_type_19, c0), offsetof(__insieme_type_19, c1), offsetof(__insieme_type_19, c2), };
size_t g_type_7_components_offset[] = {offsetof(__insieme_type_24, c0), offsetof(__insieme_type_24, c1), offsetof(__insieme_type_24, c2), offsetof(__insieme_type_24, c3), offsetof(__insieme_type_24, c4), offsetof(__insieme_type_24, c5), offsetof(__insieme_type_24, c6), };
size_t g_type_10_components_offset[] = {offsetof(__insieme_type_28, c0), offsetof(__insieme_type_28, c1), offsetof(__insieme_type_28, c2), offsetof(__insieme_type_28, c3), };

// --- the type table ---
irt_type g_insieme_type_table[] = {
    {IRT_T_UINT32, sizeof(irt_type_id), 0, 0, 0},
    {IRT_T_INT32, sizeof(const int32_t), 0, 0, 0},
    {IRT_T_POINTER, sizeof(const int32_t*), 1, g_type_2_components, 0},
    {IRT_T_POINTER, sizeof(__insieme_type_11*), 0, 0, 0},
    {IRT_T_STRUCT, sizeof(__insieme_type_19), 3, g_type_4_components, g_type_4_components_offset},
    {IRT_T_INT32, sizeof(int32_t), 0, 0, 0},
    {IRT_T_POINTER, sizeof(int32_t*), 1, g_type_6_components, 0},
    {IRT_T_STRUCT, sizeof(__insieme_type_24), 7, g_type_7_components, g_type_7_components_offset},
    {IRT_T_POINTER, sizeof(char*), 0, 0, 0},
    {IRT_T_POINTER, sizeof(char**), 1, g_type_9_components, 0},
    {IRT_T_STRUCT, sizeof(__insieme_type_28), 4, g_type_10_components, g_type_10_components_offset}
};

// --- the meta info table --- 
irt_meta_info_table_entry g_insieme_meta_table[] = {
    {{ false, 0, 0 },{ false, 0, -1, -1, 0, -1, -1, 0, -1, -1, 0, -1, -1, (0x7fffffff * 2U + 1U), (0x7fffffff * 2U + 1U) },{ false, false, (0x7fffffff * 2U + 1U), (0x7fffffff * 2U + 1U) },{ false, {0}, {0}, 0, 0, 0 },{ false, "" }}, /* the no-info-entry */

};

struct __insieme_type_11 {
    double data[100];;
};

/* ------- Function Definitions --------- */
int32_t IMP_main() {
    const int32_t var_0 = 100;
    __insieme_type_11 var_1;
    {
        irt_merge(irt_parallel(&INS_INIT(irt_parallel_job){(uint64_t)4, (uint64_t)4, 1ul, &g_insieme_impl_table[0], (irt_lw_data_item*)(&INS_INIT(__insieme_type_19){4, &var_0, &var_1})}));
    };
    int32_t var_2 = 0;
    int32_t var_3 = 0;
    int32_t var_4 = 0;
    int32_t var_5 = 0;
    {
        irt_merge(irt_parallel(&INS_INIT(irt_parallel_job){1ul, 4294967295ul, 1ul, &g_insieme_impl_table[1], (irt_lw_data_item*)(&INS_INIT(__insieme_type_24){7, &var_0, &var_1, &var_2, &var_3, &var_4, &var_5})}));
    };
    return 0;
}
struct __insieme_type_26;
typedef struct __insieme_type_26 __insieme_type_26;

struct __insieme_type_26 {
    irt_type_id c0;
    int32_t* c1;;
};

/* ------- Function Definitions --------- */
void insieme_wi_2_var_0_impl(irt_work_item* var_0) {
    *(*(__insieme_type_26*)(*var_0).parameters).c1 = IMP_main();
}
/* ------- Function Definitions --------- */
void _ins_omp_parallel_2(const int32_t* var_0, __insieme_type_11* var_1) {
    {
        {
            for (int32_t var_2 = 0; var_2 < *var_0; ++var_2) {
                (*var_1).data[var_2] = (double)((int32_t)irt_wi_get_wg_num(irt_wi_get_current(), 0u));
            };
        };
    };
    irt_wi_join_all(irt_wi_get_current());
}
/* ------- Function Definitions --------- */
void insieme_wi_0_var_0_impl(irt_work_item* var_0) {
    _ins_omp_parallel_2((*(__insieme_type_19*)(*var_0).parameters).c1, (*(__insieme_type_19*)(*var_0).parameters).c2);
}
/* ------- Function Definitions --------- */
void _ins_omp_parallel_3(const int32_t* var_0, __insieme_type_11* var_1, int32_t* var_2, int32_t* var_3, int32_t* var_4, int32_t* var_5) {
    {
        {
            for (int32_t var_6 = 0; var_6 < *var_0; ++var_6) {
                if ((*var_1).data[var_6] == (double)0) {
                    irt_atomic_fetch_and_add(var_2, 1, int32_t);
                } else {
                    if ((*var_1).data[var_6] == (double)1) {
                        irt_atomic_fetch_and_add(var_3, 1, int32_t);
                    } else {
                        if ((*var_1).data[var_6] == (double)2) {
                            irt_atomic_fetch_and_add(var_4, 1, int32_t);
                        } else {
                            if ((*var_1).data[var_6] == (double)3) {
                                irt_atomic_fetch_and_add(var_5, 1, int32_t);
                            };
                        };
                    };
                };
            };
        };
    };
    irt_wi_join_all(irt_wi_get_current());
}
/* ------- Function Definitions --------- */
void insieme_wi_1_var_0_impl(irt_work_item* var_0) {
    _ins_omp_parallel_3((*(__insieme_type_24*)(*var_0).parameters).c1, (*(__insieme_type_24*)(*var_0).parameters).c2, (*(__insieme_type_24*)(*var_0).parameters).c3, (*(__insieme_type_24*)(*var_0).parameters).c4, (*(__insieme_type_24*)(*var_0).parameters).c5, (*(__insieme_type_24*)(*var_0).parameters).c6);
}
// --- work item variants ---
irt_wi_implementation_variant g_insieme_wi_0_variants[] = {
    { &insieme_wi_0_var_0_impl, 0, NULL, 0, NULL,  &(g_insieme_meta_table[0]) },
};
irt_wi_implementation_variant g_insieme_wi_1_variants[] = {
    { &insieme_wi_1_var_0_impl, 0, NULL, 0, NULL,  &(g_insieme_meta_table[0]) },
};
irt_wi_implementation_variant g_insieme_wi_2_variants[] = {
    { &insieme_wi_2_var_0_impl, 0, NULL, 0, NULL,  &(g_insieme_meta_table[0]) },
};
// --- the implementation table --- 
irt_wi_implementation g_insieme_impl_table[] = {
    { 1, 1, g_insieme_wi_0_variants },
    { 2, 1, g_insieme_wi_1_variants },
    { 3, 1, g_insieme_wi_2_variants },
};

void insieme_init_context(irt_context* context) {
    context->type_table_size = 11;
    context->type_table = g_insieme_type_table;
    context->impl_table_size = 3;
    context->impl_table = g_insieme_impl_table;
    context->info_table_size = 1;
    context->info_table = g_insieme_meta_table;
    context->num_regions = 1;
}

void insieme_cleanup_context(irt_context* context) {
}

/* ------- Function Definitions --------- */
int32_t main(int32_t var_0, char** var_1) {
    int32_t var_2 = 0;
    irt_runtime_standalone(irt_get_default_worker_count(), &insieme_init_context, &insieme_cleanup_context, &g_insieme_impl_table[2], (irt_lw_data_item*)(&INS_INIT(__insieme_type_28){10, var_0, var_1, &var_2}));
    return var_2;
}


